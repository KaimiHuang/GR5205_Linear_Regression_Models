# -*- coding: utf-8 -*-
"""Bitcoin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dhSRY9izE5z7YhMQFO5x1Ut2DtmSVdsL
"""

from google.colab import drive
drive.mount('/content/drive') 
import os

os.chdir('/content/drive/My Drive/GR5205 GU4205 Linear Regression Models Team Project')
os.getcwd()

import pandas as pd
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.stats.stattools import jarque_bera, durbin_watson
from statsmodels.stats.diagnostic import het_breuschpagan
from statsmodels.stats.outliers_influence import variance_inflation_factor
from sklearn.metrics import mean_squared_error,r2_score

ts_df = pd.read_csv('./BTC_3.csv')
ts_df = ts_df.dropna()

#scale BTC Volume
ts_df['BTC Volume'] = ts_df['BTC Volume']/1000000

#remove an outlier
#outlier is defined as a max in this content
ts_df = ts_df[ts_df['BTC Volume']!=ts_df['BTC Volume'].max()]
ts_df.rename(columns = {'Bitcoin My Wallet Number of Transaction Per Day':'My Wallet Tnsctns'},inplace=True)

#predictors
X = ts_df.loc[:,['BTC Volume',
           'My Wallet Tnsctns',
           'NVDA',
           'Ethereum',
           'DJI'
]]

#response
response = 'BTC'
y = ts_df[response]

#simple linear regression
predictor_slr = 'Ethereum'
X_slr = ts_df[predictor_slr]
X_slr_ac = sm.add_constant(X_slr)
model_slr = sm.OLS(y, X_slr_ac).fit()
print(model_slr.summary())

residuals_slr = model_slr.resid
fitted_values_slr = model_slr.fittedvalues

plt.figure(figsize=(5, 4)) # (width, height)
sns.scatterplot(x=X_slr, y=y, alpha=0.75) 
plt.plot(X_slr,fitted_values_slr, label='OLS Best Fit Line',color = 'red', linewidth=4)
plt.title(f'{response} vs {predictor_slr}', fontsize=18)
plt.xlabel(predictor_slr, fontsize=15)
plt.ylabel(response, fontsize=15)
plt.legend()
plt.show()

sns.pairplot(X,diag_kind='hist')
plt.show()

ts_df_melted = pd.melt(ts_df,id_vars = ['Date'],value_vars=['BTC', 'BTC Volume', 'My Wallet Tnsctns', 'NVDA', 'Ethereum',
       'DJI'])
sns.lineplot(data=ts_df_melted,x='Date',y='value',hue='variable')
plt.show()

#multiple linear regression
#OLS
X_ac = sm.add_constant(X)
model_mlr = sm.OLS(y, X_ac).fit()
print(model_mlr.summary())
residuals_mlr = model_mlr.resid
fitted_values_mlr = model_mlr.fittedvalues

#multiple linear regression
#GLS
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
def ar1_covariance_matrix(N,rho,sigma2):  
    covariance_matrix=np.zeros((N,N))
    for i in range(N):
        for j in range(i+1):
            x=sigma2*(rho**abs(i-j))
            covariance_matrix[i,j]=x
            covariance_matrix[j,i]=x
    return covariance_matrix

data=residuals_mlr
N=len(data)
#estimate phi/rho, the error autocrrelation at lag s, using ols residuals
#rho1=phi1, rhos=phi^s
#order: (p, d, q) where p is the order of the autoregressive (AR) part, d is the degree of differencing, and q is the order of the moving average (MA) part
ar1_model=ARIMA(data,order=(1,0,0)).fit()
rho=ar1_model.params[1]

residuals=ar1_model.resid
sigma2=np.var(residuals)/(1-rho**2)
covariance_matrix=ar1_covariance_matrix(N,rho,sigma2)

myGLS=sm.GLS(y,X_ac,sigma=covariance_matrix).fit()
print(myGLS.summary())
residuals_gls = myGLS.resid
fitted_values_gls = myGLS.fittedvalues

#back test GLS model using daily data from the year prior
ts_df_bt = pd.read_csv('./BTC_backtest.csv')
ts_df_bt.drop(columns = ['Unnamed: 7','Unnamed: 8'],inplace=True)
ts_df_bt.dropna(inplace=True)
ts_df_bt.rename(columns={'BTC Volume mln':'BTC Volume', 'Bitcoin My Wallet Number of Transaction Per Day':'My Wallet Tnsctns'},inplace=True)

#predictors
X_bt = ts_df_bt.loc[:,['BTC Volume',
           'My Wallet Tnsctns',
           'NVDA',
           'Ethereum',
           'DJI'
]]

#response
y_bt = ts_df_bt[response]

X_bt_ac = sm.add_constant(X_bt)
y_pred_gls = myGLS.predict(X_bt_ac)

mse_gls=mean_squared_error(y_bt,y_pred_gls)
r2_gls=r2_score(y_bt,y_pred_gls)
print("GLS MSE:",mse_gls)
print("GLS R-squared",r2_gls)

y_pred_ols = model_mlr.predict(X_bt_ac)
mse_ols=mean_squared_error(y_bt,y_pred_ols)
r2_ols=r2_score(y_bt,y_pred_ols)
print("OLS MSE:",mse_ols)
print("OLS R-squared",r2_ols)

#check linearity between residuals and fitted values
plt.figure(figsize=(5, 4)) # (width, height)
sns.scatterplot(x=fitted_values_mlr, y=residuals_mlr, alpha=0.75) # alpha for transparency
plt.title('Residuals vs Bitcoin Price Fitted Values', fontsize=18)
plt.xlabel('Bitcoin Price Fitted Values', fontsize=15)
plt.ylabel('Residuals', fontsize=15)
plt.show()

#check normality of residuals
#using Quantile-Quantile plot
fig = sm.qqplot(residuals_mlr, line='s')
plt.title('Q-Q Plot')
plt.show()

residuals_mlr_np = residuals_mlr.to_numpy()
sns.kdeplot(residuals_mlr_np.reshape(-1), shade=True)
plt.title('Probability Density Function of Residuals', fontsize=15)
plt.show()

jbtest = jarque_bera(residuals_mlr)
JB_test_sta = jbtest[0]
JB_test_p_value = jbtest[1]
JB_test_skewness = jbtest[2]
JB_test_kurtosis = jbtest[3]
print(f'Test Results: \
  Jarque-Bera Test Statistic: {JB_test_sta},\
  P-value: {JB_test_p_value},\
  Skewness: {JB_test_skewness},\
  Kurtosis: {JB_test_kurtosis}')

#check autocorrelation
dwtest = durbin_watson(residuals_mlr)
print(f'Durbin-Watson Test Statistic: {dwtest}')

# Run the Breusch-Pagan test to check homoscedasticity 
bptest = het_breuschpagan(residuals_mlr, X)
bptest_sta = bptest[0]
bptest_p_value = bptest[1]
print(f'Breusch-Pagan Test Statistic: {bptest_sta}, and P-value: {bptest_p_value}')

#check multicollinearity
sns.heatmap(X.corr(),mask=np.triu(X.corr()),annot=True, cmap='PiYG')
plt.show()


vif = [variance_inflation_factor(X.values,i)for i in range(X.shape[1])]
for ind, col in enumerate(X.columns):
    print(f'VIF({col}): {vif[ind]}')